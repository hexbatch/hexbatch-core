

  todo add new standard types for rendering rule_parts and path_parts: these have a standard attribute controlling the shape of the part.
   Each rule and path part have standard attributes that match each internal db column
   As elements, these can represent the rules and paths as chains of parent child sets, with each part sibling being in the same set.
   Make new standard set for holding an element for each action, and a single element for the path part.
   Adjust the color here in the set for rendering. When the debugger mode is used, this set->element rendering of the rule chains and paths are sent with the rest above

  todo same for api calls as above, each of the api call types, defined already, has an element in the same standard set, where the color of shape of the api call is done

  todo for visual debugging, there are new standard types for each of the logic , in the same way as above, and these elements are put into the set to adjust as needed.
    the linkages in the tree use this logic element to help render


       note: type and attribute creating, editing and deletion and publishing are also done by actions
      todo: add TypeTemplate, AttributeTemplate with attributes that describe the settings for each
      todo: add Actions that create, edit and edit using the templates above, and delete using the found attr or types in the path
      	if type in use the editing and deleting are going to fail. Editing type can change the lifecycle, can publish this way.
      	To edit, make new element of template, set the proper attributes, put in any set, and then call the action
      todo: each attribute and type setting should be an attribute in the TypeDesign and AttributeDesign




°º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

rules should have old fashoned events, signals, mutexes and semaphores


-----------


type signal base type
 rules can wait on signals, if a parent completes, the child rule will not wait more
  (if the parent logic decides enough children ran) the parent thing can short circuit

----


type mutex, inhertit from signal, allows for one thing to be done at a time
    it has attributes child can make own from:
     is_one_time default false


each mutex type only has one element, other elements cannot be made,

mutexs are only allowed to be in two set types. Each element can only be in one set at a time
	global system set mutex_waiting is where mutexes that are not claimed are at. There is only one set of this per server.
	set type local_signal_claimed is where a thing collection root can put mutexes into when they are claimed by the rules.
	This is made when the rule is waiting, and deleted when the rule is done
    if is_one_time then the element for the mutex is destroyed and nothing can use it until another element is made
A mutex for use inherits from the base mutex and the ns type,  a normal type creation


new rule actions
 todo new event mutex_wait  - will claim mutex, moving it from the mutex_waiting set, if not there will wait indefinately
                     When there its put it into set type local_signal_claimed at the thing node that is waiting
                     when thing node is done, the set is destroyed and the claimed is put into mutex_waiting again.
                     It is automatically released after thing row is done, even after indefinate time.
                     Then the next wait can grab it.
                     can wait for multiple mutexes at once if the path finds more than one to use for the rule,
                      all the mutexes must be ready
                      or mutex use of types can be nested in the rule chain
                     can wait for ancestor of mutex but not for system type

 todo new event mutex_or_bust - will return false for the thing row if the mutux is not avialble when the thing row runs,
                            otherwise it is like the above

note: mutex_or_bust can make sure only one event handler will process for any fired event


type semaphore inherits from signal
    it has attributes child can make own from:
         max_time_to_wait_seconds default null
         is_automatically_waiting : default false
         seconds_in_wait_idle : default null
         when_put_in_wait : default null

 this has N elements for however many semaphores can be used at once
 elements start in the global set semaphore_idle unless the automatic flag is set, then they go into semaphore_waiting.
 todo The command semaphore_ready will move the pathed elements to the semaphore_waiting from semaphore_idle
 todo the command semaphore_reset will move the pathed elements the opposite way from waiting to idle,
  and anything waiting on those elements will signal false to the parent thing

 when waiting to be used, the semaphores are in the global set semaphore_waiting,
   this set allows all elements of the semaphore type to be there, but nothing else.

   if seconds_in_wait_idle is used, then the semaphore cannot be claimed until its wait time is up, this allows for minimum pauses between events

   if the type defines the max_time_to_wait, then the wait will be cancelled, and the thing row sends false to its parent

 todo new event semaphore_wait - does much like the above, just different global set to find the semaphore semaphore_waiting.
                                also can wait for multiple semaphore types, or different elements from the same type, all of which must be ready;
                                when done the semaphore elements go back to the idle or waiting, based on the auto attribute


 todo new event semaphore_wait_any - like above, but first semaphore free in the target path will allow rule to run, rest are ignored

 note: if you need to wait for any mutex, make them a semaphore with only one element
 note: to cast votes make semaphore element for each vote, to start an election then move all votes to unused.
 	In the semaphore type do action in rule to move to waiting when value of attribute set, using the write event for the vote being done
 	elsewhere have something waiting for all the votes to be in active before it runs, using the semaphore_wait.
 	This way things can be done when elements are written to in some combination.
 	The other option is to use a remote to count the changes, then toggle a manual remote.
 	This way, everything is defined in the rules and less tampering
