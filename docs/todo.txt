


  todo all shape filters need admin priv for both attr

  note: api can be chained together in the things by linking them as child parent with and/or

  °º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

  todo: route to use api chaining via json, the route chaining can have logical conditions using path api returning stuff, because that is an api too,
        so basically any api result can be used for a logical condition to do other api at the same time or one after the other or both


°º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

  todo add debug_things to .env: when calling any api, optional debuggging (break_on_first means pause before any node of thing is run here) and url for callback can be made, if member of server group,
      all data seen, and the url provided gets updated with each completed or failed thing
      this is done by adding a new thing result row, in addition to the user calling the api, a debug row is set for the thing,
      when a thing row is debugged, all decendants of the thing has its final status sent to the url
      when debugging, send all the thing tree, and any attatched rule tree, and any attached path tree,before any run, at once, to the url.
       Then, the debugger can set up break points and or start single step, or allow to run.

  todo in thing_results add debugging|single_step|breakpoint to type_api_followup, all send the thing results to the api or let be polled
    single step means that the next thing ready to run will wait for the debugger to call an api for the thing to continue
    breakpoint means the things will continue until reaching that breakpoint


  todo in thing states add paused, to stop auto running of things, when the debugger is single stepping


   todo new api for setting next step, making and clearing debug points, running from the paused, and removing the thing running (branch or top thing) if branch removed,
    its logic to parent is false, and it pipes nothing
   todo new api for server admin getting any thing tree, and to search things


   °º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

  todo when a rule targets multiple elements, regardless of action, they all get put into the thing collection, If the action for any element results in an event.
    Then that thing is queued to run, and its thing id is put into the same row in the thing collection. The thing collection has a new column for is_ready
    when all is ready (all things return from this or there was no event to begin with), then all the thing collection is applied at once. Or none is, and that rule fails.
    Do exponential backoff times to the new things added via thing-set if there is too much depth.
  todo put in thing_id to thing_set, and the enum above

  The parent thing can add the child results (types,elements, attr, ns,sets) if there is a pipe, or filter to remove items in the parent thing collection.
  Rules can only search in the parent thing collection by paths, the children are popped.  Rules can only read the thing collection, not modify its contents.



  todo new column in element set members, need rank, unique member + rank per set

  todo ns membership can get membership ns from piped in ns

  todo live types have api call join and split, this can have a list of types and a list of elements from piping|filtering



  todo add new standard types for rendering rule_parts and path_parts: these have a standard attribute controlling the shape of the part.
   Each rule and path part have standard attributes that match each internal db column
   As elements, these can represent the rules and paths as chains of parent child sets, with each part sibling being in the same set.
   Make new standard set for holding an element for each action, and a single element for the path part.
   Adjust the color here in the set for rendering. When the debugger mode is used, this set->element rendering of the rule chains and paths are sent with the rest above

  todo same for api calls as above, each of the api call types, defined already, has an element in the same standard set, where the color of shape of the api call is done

  todo for visual debugging, there are new standard types for each of the logic , in the same way as above, and these elements are put into the set to adjust as needed.
    the linkages in the tree use this logic element to help render

  todo new column on the element values, parent child set relations, and links, can have a descriptive element added, make new element id column for the linkage

  note: for remote types, they can be described by elements, for any remote type, just adjust their description visual. The remote_return type, that is made with the remote can be adjusted too.


  todo for the remote return type, the http code has an "always" attribute to hold that, and then either success or fail attributes will be filled out in the type's descriptive element
    and this is used for rendering the visual, and for doing stuff using that in the rules (remote results are put in the top level thing collection for rules to find)
  todo add new type for the remote cache, with standard attr for behavior of cache
  todo add new type for the remote rules, with standard attr for each rule setting
  todo add new type for the remote to send data, the base has no attributes, except required and optional body, required and optional headers,  but derived have attributes for each field inheriting this.
     if not all required are filled in by remotes, then this remote call ends in failure before sent.
  note: when remote type is created, it has the cache and rules elements for it put in a standard set for remotes.
  todo: new system set for remote cache and remote rules
  todo: when remote called, it is at the closest parent thing that has children that does not call the remote again, as a set containing the remote, its possible return, the data to send, its cache and rules. These are all read only to the remotes, except for the data to send.
  todo: add attributes for remote response for headers, code and body
  todo: remote can have localhost or ip or server domain if the owner of the remote is member of server ns
  todo: thing_results can have callback localhost, ip, or server domain also if the caller is member of server
  todo: new attribute for remote rules, max time to wait, where the thing row will not wait on it after N seconds
  note: remotes cannot be called if out of the map, path or time bounds for the attribute holding the rule. This is already covered by how the thing rows are populated,
  using only attributes that exist there, but it is not covered for shapes, so use the blocking shape stuff for that


°º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

  todo: make new standard_alias table, for having the names of the standard types and attributes in different languages (type_id, attribute_id, iso lang, name)
    the names for all types here are unique, same for attributes, put the english here too to enforce uniqueness. When a name is used, look up the thing it refers to.
    when the type or attribute is listed in the resources, list the alias . Use the lang resource to refresh the names for all languages at once in the standard console


  todo if path is doing a count, then add ability to compare to a number. add to enum where we specify count, to include count_compare,
  	 then use the min and max of that part

  todo path can sum using an attribute see https://dba.stackexchange.com/a/214504, add in to same enum the sum, and sum_compare.
             the path also needs the json key name for the attribute, so add that in somehow to the part, as a node of type json_key_name to the enum for the typem,
             and then the top part when it finishes and decides on the return can use that child type to figure out the json col

  todo same for average|min|max for the path

  todo add to paths relationship: link_element, member_of_set , attribute_of_type, parent of thing, child of thing, member thing collection,
   action of thing (to search actions and api).

   things need a cursor for the next page, and how to know there is another page of results.
   When there is a full page for a container, the parent makes a cursor
   A new child thing is made to have its container use the parent cursor , the child may start later according to the backoff
    the child results combined or_all to the parent. Empty data for the last cursor is child success too.
   the thing parent cannot complete until all the new children return success.
   The backoff page policy uses all the thing_path_states in the thing tree to decide if to delay getting next page
  todo new table thing_path_states (thing, path,type,set,element, attribute,namespace) if there is a full page returned in a container,




  todo new placeholder for current namespace, current element, current thing-set



  todo: put in .env and config the default thing_pagination_size,thing_pagination_limit,depth,rate,backoff,json size


  todo: on the attribute enum add element owner readable|type owner writable, even if the type is locked down

  todo when doing z-index on the shapes, the different api calls are attached to the same root (the event called) with the specified logic,
    but the higher z-index are children of the lower z-index

  note: rest of api mirror the actions and events


  °º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸


   type and attribute creating, editing and deletion and publishing are also done by actions
  todo: add TypeTemplate, AttributeTemplate with attributes that describe the settings for each
  todo: add Actions that create, edit and edit using the templates above, and delete using the found attr or types in the path
  	if type in use the editing and deleting are going to fail. Editing type can change the lifecycle, can publish this way.
  	To edit, make new element of template, set the proper attributes, put in any set, and then call the action
  todo: add path being able to find attributes and types based on their settings,
  todo: also path should find rules that use stuff in sub path parts, and select based on that
         but this is only for those able to read the rules.
  todo: if other server tries to talk to type here, and its deleted or suspended, then let them know by http error code
  todo: the api for types and attributes use the new actions here, through the things, to do the work. What they do is gather data from the incoming json or route, and push to things

  note: the listing and showing of the types and attributes, rules are still using resources with the models
  todo: add action for changing the type ownership (to a different ns),and changing element ownership, add events for these, if not exist yet. Add api for this.

  note: urls for image, svg, file checking will be done in the next layer, where it downloads and scans, accepting or rejecting it,
    the system user can hook into the descendants of the url attributes to deny the value change or accept it.
    	see
  todo: put base url attribute, and outside_url (to mark urls that need checking with url as parent) at system root, inherit all urls in the other types from one of these
  todo: put downloadable_url as attribute in media

  todo: need event when setting attribute value (called when published)
  todo: add file attribute somewhere in the standards (do I put remote_url as a system attr at the top? and inherit the others from that?)
  note: never store html or xml in the json values, plain text can be in a key



°º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸


 //todo what is package access vs public, how to define a package across servers?
  (server, type, access_level)
  todo adjust element_type_server_whitelist to  (server, type, access_level) -> public, protected, package
     if server is null, then this applies to all servers  (add unique key to include nulls for server and type). Ancestor types cannot increase access, only lessen it


  todo add package to type_of_server_access, remove the read only and just set for the public, protected, package, and private

  note: the reported events to send, and the denied events, are discovered by the server events combined with the attribute access level
        so if the type has a hook for element creation, but that or those attributes are not included in the elsewhere access level
         (the attr are protected and the server is package example)
	 This will be reported as type that an event set, or that it exists but is forbidden
	 types from other servers that do not have a forbidden event, or a defined event, will not have an entry in the server_events

  todo add enum flag to server_events use_handler|forbidden


 note: if an element is only readable or writable by a ns, then an event listener is added by the server and the attribute must be marked as private ??





todo: ns has token, and public key, used by server comms and verifing stuff done in remotes


todo: make table to show which elements were exported (type_id,element_id(nullable),server_id), and can show which types if all elements deleted .
 set one row with type and null element for each type exported



°º¤ø,¸¸,ø¤º°`°º¤ø,¸,ø¤°º¤ø,¸¸,ø¤º°`°º¤ø,¸

rules should have old fashoned events, signals, mutexes and semaphores


custom events inherit from Event and the NS type, they can be fired and can be listended to all at the same time (scoped or no)
todo new action fire_custom_event, rule just puts event type in the rule_action_or_event_type_id to listenm, the custom event creation is just a normal type creation


-----------


type signal base type
 rules can wait on signals, if a parent completes, the child rule will not wait more
  (if the parent logic decides enough children ran) the parent thing can short circuit

----


type mutex, inhertit from signal, allows for one thing to be done at a time
    it has attributes child can make own from:
     is_one_time default false


each mutex type only has one element, other elements cannot be made,

mutexs are only allowed to be in two set types. Each element can only be in one set at a time
	global system set mutex_waiting is where mutexes that are not claimed are at. There is only one set of this per server.
	set type local_signal_claimed is where a thing collection root can put mutexes into when they are claimed by the rules.
	This is made when the rule is waiting, and deleted when the rule is done
    if is_one_time then the element for the mutex is destroyed and nothing can use it until another element is made
A mutex for use inherits from the base mutex and the ns type,  a normal type creation


new rule actions
 todo new event mutex_wait  - will claim mutex, moving it from the mutex_waiting set, if not there will wait indefinately
                     When there its put it into set type local_signal_claimed at the thing node that is waiting
                     when thing node is done, the set is destroyed and the claimed is put into mutex_waiting again.
                     It is automatically released after thing row is done, even after indefinate time.
                     Then the next wait can grab it.
                     can wait for multiple mutexes at once if the path finds more than one to use for the rule,
                      all the mutexes must be ready
                      or mutex use of types can be nested in the rule chain
                     can wait for ancestor of mutex but not for system type

 todo new event mutex_or_bust - will return false for the thing row if the mutux is not avialble when the thing row runs,
                            otherwise it is like the above

note: mutex_or_bust can make sure only one event handler will process for any fired event

todo new event, thing_destroyed (to let sets do actions and/or delete themselves when a thing row set is destroyed)

type semaphore inherits from signal
    it has attributes child can make own from:
         max_time_to_wait_seconds default null
         is_automatically_waiting : default false

 this has N elements for however many semaphores can be used at once
 elements start in the global set semaphore_idle unless the automatic flag is set, then they go into semaphore_waiting.
 todo The command semaphore_ready will move the pathed elements to the semaphore_waiting from semaphore_idle
 todo the command semaphore_reset will move the pathed elements the opposite way from waiting to idle,
  and anything waiting on those elements will signal false to the parent thing

 when waiting to be used, the semaphores are in the global set semaphore_waiting,
   this set allows all elements of the semaphore type to be there, but nothing else

   if the type defines the max_time_to_wait, then the wait will be cancelled, and the thing row sends false to its parent

 todo new event semaphore_wait - does much like the above, just different global set to find the semaphore semaphore_waiting.
                                also can wait for multiple semaphore types, or different elements from the same type, all of which must be ready;
                                when done the semaphore elements go back to the idle or waiting, based on the auto attribute


 todo new event semaphore_wait_any - like above, but first semaphore free in the target path will allow rule to run, rest are ignored

 note: if you need to wait for any mutex, make them a semaphore with only one element
 note: to cast votes make semaphore element for each vote, to start an election then move all votes to unused.
 	In the semaphore type do action in rule to move to waiting when value of attribute set, using the write event for the vote being done
 	elsewhere have something waiting for all the votes to be in active before it runs, using the semaphore_wait.
 	This way things can be done when elements are written to in some combination.
 	The other option is to use a remote to count the changes, then toggle a manual remote.
 	This way, everything is defined in the rules and less tampering





todo new table thing_waits
      the thing_id, waiting_on_type, expires_at, enum thing_waiting_type wait_all|wait_one, timestamps


todo when thing runs looking for the next batch of rows to run, do the check on the thing_waits every so often and make those expired rows return false to parent, and clean up resources for remote sets

todo on the standard signal sets mentioned above, define the rules in the sys creation for the set-definer element on those

note: how to use the thing collections for signals and remote
 for signals
 when the thing runs, fill in row thing_waits using the signal type and possible expiration
 use this to find the rows waiting for this event, and to cancel events. If a mutex has all elements destroyed, then the things waiting on that will return false.

 for remotes, put in the remote result type that is being waited on. If waiting on that remote to finish up, and it goes past the optional time limit,
 then the remote call should be abandoned, then get the remote set at the row or ancestor , and remove it if no other waiting on the same remote


note: when a mutex element is destroyed, find any rows waiting for that type in the thing-set , and make them be false to the parent






